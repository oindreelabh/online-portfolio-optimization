"""
Advanced Analytics Tab

Displays outputs generated by evaluation & analysis scripts:
- performance_comparison.py        -> metrics_table.csv, portfolio_equity.csv, predictions_long.csv, equity_curves.html, drawdowns.html, sharpe.html
- portfolio_metrics.py             -> portfolio_timeseries.csv, equity.html, drawdown.html, rolling_vol.html
- allocation_evolution.py          -> allocation_summary.csv, allocation_evolution.html, concentration.html
- transaction_cost_impact.py       -> tc_impact.csv, turnover_plot.html
- sentiment_influence.py           -> sentiment_correlations.csv, *_predicted_return.html, *_alloc_delta.html

Users pick (or type) base directories; tab auto-detects artifacts.
All functions use snake_case and include basic error handling.
"""
import os
import pandas as pd
import streamlit as st
import plotly.express as px
import numpy as np
from typing import Optional
import subprocess
import textwrap

def _safe_read_csv(path: str) -> Optional[pd.DataFrame]:
    if path and os.path.exists(path):
        try:
            return pd.read_csv(path)
        except Exception as e:
            st.warning(f"Failed reading {os.path.basename(path)}: {e}")
    return None

def _list_html(path: str, contains: str):
    if not path or not os.path.isdir(path):
        return []
    return [os.path.join(path, f) for f in os.listdir(path)
            if f.lower().endswith(".html") and contains in f]

def _display_html_file(path: str, label: str):
    try:
        import streamlit.components.v1 as components
        with open(path, "r", encoding="utf-8") as f:
            html_content = f.read()
        with st.expander(label, expanded=False):
            components.html(html_content, height=500, scrolling=True)
    except Exception as e:
        st.warning(f"Error embedding {os.path.basename(path)}: {e}")

def _section_header(title: str):
    st.markdown(f"### {title}")

def _run_cmd(cmd_list):
    """Run a subprocess command and stream output."""
    try:
        proc = subprocess.run(cmd_list, capture_output=True, text=True, check=False)
        if proc.stdout:
            st.text(proc.stdout.strip()[:8000])
        if proc.returncode != 0:
            st.warning(f"Command failed (exit {proc.returncode}): {' '.join(cmd_list)}\n{proc.stderr[:500]}")
        return proc.returncode == 0
    except Exception as e:
        st.warning(f"Subprocess error: {e}")
        return False

def _maybe_generate_artifacts(project_root, perf_dir, metrics_dir, alloc_dir, tc_dir, senti_dir):
    """
    Generate missing analytics artifacts by invoking evaluation / analysis scripts.
    Only runs scripts whose primary output files are absent.
    """
    st.info("Checking for missing analytics artifacts...")
    scripts_run = []

    # Paths & required outputs
    hist_prices = os.path.join(project_root, "data", "processed", "stock_prices_historical.csv")
    recent_sent = os.path.join(project_root, "data", "processed", "recent_data_with_sentiment.csv")
    lstm_model = os.path.join(project_root, "models", "lstm_model.keras")
    lstm_scaler = os.path.join(project_root, "models", "lstm_model_scaler.pkl")
    ogdm_model = os.path.join(project_root, "models", "ogdm_model.pkl")

    # 1. Performance comparison
    perf_metrics = os.path.join(perf_dir, "metrics_table.csv")
    if not os.path.exists(perf_metrics):
        if all(os.path.exists(p) for p in [hist_prices, lstm_model, lstm_scaler, ogdm_model]):
            os.makedirs(perf_dir, exist_ok=True)
            cmd = [
                "python", "-m", "src.evaluation.performance_comparison",
                "--data-csv", hist_prices,
                "--lstm-model", lstm_model,
                "--lstm-scaler", lstm_scaler,
                "--ogdm-model", ogdm_model,
                "--sequence-length", "5",
                "--output-dir", perf_dir
            ]
            st.write("Running performance comparison...")
            if _run_cmd(cmd):
                scripts_run.append("performance_comparison")
        else:
            st.warning("Skipping performance comparison (required models/data missing).")

    # 2. Portfolio metrics
    pm_csv = os.path.join(metrics_dir, "portfolio_timeseries.csv")
    if not os.path.exists(pm_csv) and os.path.exists(hist_prices):
        os.makedirs(metrics_dir, exist_ok=True)
        cmd = [
            "python", "-m", "src.evaluation.portfolio_metrics",
            "--prices-csv", hist_prices,
            "--output-dir", metrics_dir,
            "--roll-window", "20",
            "--make-plots"
        ]
        st.write("Running portfolio metrics...")
        if _run_cmd(cmd):
            scripts_run.append("portfolio_metrics")

    # 3. Allocation evolution (needs weights CSV). If missing, synthesize simple equal-weight file from historical prices.
    alloc_summary = os.path.join(alloc_dir, "allocation_summary.csv")
    if not os.path.exists(alloc_summary):
        os.makedirs(alloc_dir, exist_ok=True)
        weights_csv = os.path.join(alloc_dir, "synthetic_weights.csv")
        if not os.path.exists(weights_csv) and os.path.exists(hist_prices):
            try:
                df_prices = pd.read_csv(hist_prices)
                if {"date", "ticker", "close"}.issubset(df_prices.columns):
                    # Use last 60 dates to reduce size
                    df_prices["date"] = pd.to_datetime(df_prices["date"])
                    last_dates = sorted(df_prices["date"].unique())[-60:]
                    temp = df_prices[df_prices["date"].isin(last_dates)]
                    ew_rows = []
                    for d, g in temp.groupby("date"):
                        tickers = sorted(g["ticker"].unique())
                        if not tickers:
                            continue
                        w = 1 / len(tickers)
                        for t in tickers:
                            ew_rows.append({"date": d, "ticker": t, "weight": w})
                    pd.DataFrame(ew_rows).to_csv(weights_csv, index=False)
                    st.info("Created synthetic equal-weight allocation CSV for evolution analysis.")
            except Exception as e:
                st.warning(f"Failed synthesizing weights: {e}")
        if os.path.exists(weights_csv):
            cmd = [
                "python", "-m", "src.analysis.allocation_evolution",
                "--weights-csv", weights_csv,
                "--output-dir", alloc_dir,
                "--min-weight", "0.0"
            ]
            st.write("Running allocation evolution...")
            if _run_cmd(cmd):
                scripts_run.append("allocation_evolution")

    # 4. Transaction cost impact (needs predictions from performance comparison)
    tc_csv = os.path.join(tc_dir, "tc_impact.csv")
    predictions_long = os.path.join(perf_dir, "predictions_long.csv")
    if not os.path.exists(tc_csv) and os.path.exists(predictions_long):
        os.makedirs(tc_dir, exist_ok=True)
        cmd = [
            "python", "-m", "src.analysis.transaction_cost_impact",
            "--predictions-csv", predictions_long,
            "--model-name", "HYBRID",
            "--output-dir", tc_dir
        ]
        st.write("Running transaction cost impact analysis...")
        if _run_cmd(cmd):
            scripts_run.append("transaction_cost_impact")

    # 5. Sentiment influence (needs sentiment data + predictions)
    senti_corr = os.path.join(senti_dir, "sentiment_correlations.csv")
    if not os.path.exists(senti_corr) and all(os.path.exists(p) for p in [recent_sent, predictions_long]):
        os.makedirs(senti_dir, exist_ok=True)
        cmd = [
            "python", "-m", "src.analysis.sentiment_influence",
            "--data-csv", recent_sent,
            "--predictions-csv", predictions_long,
            "--model", "HYBRID",
            "--output-dir", senti_dir
        ]
        st.write("Running sentiment influence analysis...")
        if _run_cmd(cmd):
            scripts_run.append("sentiment_influence")

    if scripts_run:
        st.success(f"Generated artifacts via: {', '.join(scripts_run)}")
    else:
        st.info("No scripts executed (either artifacts already exist or prerequisites missing).")

def render_tab_advanced_analytics(project_root: str) -> None:
    """
    Render the Advanced Analytics tab.
    Allows directory selection & displays generated evaluation artifacts.
    """
    st.header("Advanced Analytics")

    st.markdown(
        "Provide output directories created by the evaluation & analysis scripts. "
        "Leave blank to use defaults under evaluation_results/ and analysis_results/."
    )

    col_base, col_refresh = st.columns([4, 1])
    with col_base:
        perf_dir = st.text_input(
            "Performance Comparison Output Directory",
            value=os.path.join(project_root, "evaluation_results", "perf")
        )
        metrics_dir = st.text_input(
            "Portfolio Metrics Output Directory",
            value=os.path.join(project_root, "evaluation_results", "metrics")
        )
        alloc_dir = st.text_input(
            "Allocation Evolution Output Directory",
            value=os.path.join(project_root, "analysis_results", "alloc_evolution")
        )
        tc_dir = st.text_input(
            "Transaction Cost Output Directory",
            value=os.path.join(project_root, "analysis_results", "transaction_cost")
        )
        senti_dir = st.text_input(
            "Sentiment Influence Output Directory",
            value=os.path.join(project_root, "analysis_results", "sentiment")
        )
    with col_refresh:
        refresh = st.button("Refresh")
        generate = st.button("Auto Generate Missing Artifacts")

    if refresh:
        st.info("Refreshing data...")

    if generate:
        _maybe_generate_artifacts(project_root, perf_dir, metrics_dir, alloc_dir, tc_dir, senti_dir)
        st.stop()

    # 1. Performance Comparison
    _section_header("Model Performance Comparison")
    metrics_csv = os.path.join(perf_dir, "metrics_table.csv")
    equity_csv = os.path.join(perf_dir, "portfolio_equity.csv")
    predictions_csv = os.path.join(perf_dir, "predictions_long.csv")

    metrics_df = _safe_read_csv(metrics_csv)
    equity_df = _safe_read_csv(equity_csv)

    # Parse dates if present to avoid axis casting issues
    for _df in (equity_df,):
        if _df is not None and "date" in _df.columns:
            try:
                _df["date"] = pd.to_datetime(_df["date"])
            except Exception:
                pass

    if metrics_df is not None and not metrics_df.empty:
        st.subheader("Metrics Table")
        st.dataframe(metrics_df.round(4), use_container_width=True)
    else:
        st.info("metrics_table.csv not found or empty.")

    if equity_df is not None and not equity_df.empty:
        st.subheader("Equity Curves")
        eq_fig = px.line(equity_df, x="date", y="equity", color="model", title="Equity Curves (Loaded from CSV)")
        st.plotly_chart(eq_fig, use_container_width=True, key="adv_eq_curves")
        # Drawdown reconstruction
        dd_rows = []
        for model, grp in equity_df.groupby("model"):
            peak = grp["equity"].cummax()
            dd = grp["equity"] / peak - 1
            dd_rows.append(pd.DataFrame({"date": grp["date"], "model": model, "drawdown": dd}))
        dd_df = pd.concat(dd_rows)
        dd_fig = px.line(dd_df, x="date", y="drawdown", color="model", title="Drawdowns (Recomputed)")
        st.plotly_chart(dd_fig, use_container_width=True, key="adv_dd_curves")
    else:
        st.info("portfolio_equity.csv not found or empty.")

    # Embed any generated HTML plots
    for html_name in ["equity_curves.html", "drawdowns.html", "sharpe.html"]:
        html_path = os.path.join(perf_dir, html_name)
        if os.path.exists(html_path):
            _display_html_file(html_path, f"Embedded: {html_name}")

    # 2. Portfolio Metrics Timeseries
    _section_header("Portfolio Metrics Timeseries")
    pm_csv = os.path.join(metrics_dir, "portfolio_timeseries.csv")
    pm_df = _safe_read_csv(pm_csv)
    if pm_df is not None and not pm_df.empty:
        # Ensure datetime
        if "date" in pm_df.columns:
            try:
                pm_df["date"] = pd.to_datetime(pm_df["date"])
            except Exception:
                pass

        st.write("Rolling / Equity Statistics")
        # Basic summary
        last_row = pm_df.iloc[-1]
        c1, c2, c3 = st.columns(3)
        c1.metric("Final Equity", f"{last_row['equity']:.3f}")
        c2.metric("Max Drawdown", f"{pm_df['drawdown'].min():.2%}")
        c3.metric("Rolling Vol (Last)", f"{last_row.get('rolling_vol', np.nan):.2f}")
        fig_pm_eq = px.line(pm_df, x="date", y="equity", title="Equity (Portfolio Metrics)")
        st.plotly_chart(fig_pm_eq, use_container_width=True, key="adv_pm_eq")
        if "drawdown" in pm_df.columns:
            fig_pm_dd = px.line(pm_df, x="date", y="drawdown", title="Drawdown (Portfolio Metrics)")
            st.plotly_chart(fig_pm_dd, use_container_width=True, key="adv_pm_dd")
        if "rolling_vol" in pm_df.columns:
            fig_pm_vol = px.line(pm_df, x="date", y="rolling_vol", title="Rolling Volatility (Annualized)")
            st.plotly_chart(fig_pm_vol, use_container_width=True, key="adv_pm_vol")
    else:
        st.info("portfolio_timeseries.csv not found or empty.")

    for html_name in ["equity.html", "drawdown.html", "rolling_vol.html"]:
        html_path = os.path.join(metrics_dir, html_name)
        if os.path.exists(html_path):
            _display_html_file(html_path, f"Embedded: {html_name}")

    # 3. Allocation Evolution
    _section_header("Allocation Evolution & Concentration")
    alloc_summary_csv = os.path.join(alloc_dir, "allocation_summary.csv")
    alloc_df = _safe_read_csv(alloc_summary_csv)
    if alloc_df is not None and not alloc_df.empty:
        st.dataframe(alloc_df.sort_values("date").tail(20), use_container_width=True)
        conc_fig = px.line(alloc_df, x="date", y="herfindahl", title="Herfindahl Index Over Time")
        st.plotly_chart(conc_fig, use_container_width=True, key="adv_herf")
        top_fig = px.line(alloc_df, x="date", y="top_weight", title="Top Weight Over Time")
        st.plotly_chart(top_fig, use_container_width=True, key="adv_top_w")
    else:
        st.info("allocation_summary.csv not found or empty.")

    for html_name in ["allocation_evolution.html", "concentration.html"]:
        html_path = os.path.join(alloc_dir, html_name)
        if os.path.exists(html_path):
            _display_html_file(html_path, f"Embedded: {html_name}")

    # 4. Transaction Cost Impact
    _section_header("Transaction Cost Impact")
    tc_csv = os.path.join(tc_dir, "tc_impact.csv")
    tc_df = _safe_read_csv(tc_csv)
    if tc_df is not None and not tc_df.empty:
        # Ensure datetime for turnover plotting
        if "date" in tc_df.columns:
            try:
                tc_df["date"] = pd.to_datetime(tc_df["date"])
            except Exception:
                pass
        st.dataframe(tc_df.tail(30), use_container_width=True)
        # Older plotly versions may not accept list-of-columns directly; handle manually
        if {"naive_turnover", "constrained_turnover"}.issubset(tc_df.columns):
            turn_long = tc_df.melt(id_vars="date",
                                   value_vars=["naive_turnover", "constrained_turnover"],
                                   var_name="series",
                                   value_name="turnover")
            turn_fig = px.line(turn_long, x="date", y="turnover", color="series",
                               title="Turnover Comparison")
            st.plotly_chart(turn_fig, use_container_width=True, key="adv_turnover")
        savings = tc_df["cost_saving"].sum() if "cost_saving" in tc_df.columns else 0.0
        st.metric("Total Cost Saving (Î£)", f"{savings:.6f}")
    else:
        st.info("tc_impact.csv not found or empty.")

    html_turnover = os.path.join(tc_dir, "turnover_plot.html")
    if os.path.exists(html_turnover):
        _display_html_file(html_turnover, "Embedded: turnover_plot.html")

    # 5. Sentiment Influence
    _section_header("Sentiment Influence")
    senti_csv = os.path.join(senti_dir, "sentiment_correlations.csv")
    senti_df = _safe_read_csv(senti_csv)
    if senti_df is not None and not senti_df.empty:
        st.dataframe(senti_df, use_container_width=True)
        corr_fig = px.bar(senti_df, x="sentiment_feature", y="pearson_corr",
                          color="target", barmode="group",
                          title="Sentiment Correlations")
        st.plotly_chart(corr_fig, use_container_width=True, key="adv_senti_corr")
    else:
        st.info("sentiment_correlations.csv not found or empty.")

    # Embed scatter/regression HTMLs if present
    if os.path.isdir(senti_dir):
        for f in sorted(os.listdir(senti_dir)):
            if f.endswith(".html") and ("alloc_delta" in f or "predicted_return" in f):
                _display_html_file(os.path.join(senti_dir, f), f"Embedded: {f}")

    st.markdown("---")
    st.caption("If directories are empty, run the evaluation & analysis scripts first.")
